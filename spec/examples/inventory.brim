=[acme::inventory]=
-- Illustrative Example: Inventory Management
-- This file demonstrates inventory tracking patterns and is non-canonical.
-- Unlike spec/sample.brim, this file is not part of the canonical sync set
-- and may use experimental or proposed features.
--
-- Status: illustrative (not canonical)


-- canon:
-- spec/inventory_sample.brim

<<
ItemStatus,
InventoryItem,
ItemCategory,
WarehouseLocation,
StockLevel,
InventoryService,
create_inventory,
find_low_stock,
>>

log      ::= std::log
time     ::= std::time
math     ::= std::math
seqops   ::= std::seq
validate ::= std::validation

-- Type definitions

ItemId   := u64
Quantity := i32
Price    := f64

ItemCategory := |{
  Electronics :str,
  Clothing    :str,
  Food        :time.Date,
  Furniture,
  Other,
}

ItemStatus := &{
  available,
  reserved,
  damaged,
  recalled,
}

WarehouseLocation := %{
  warehouse_id :u32,
  aisle        :str,
  shelf        :u32,
  bin          :u32,
}

StockLevel := |{
  InStock    :Quantity,
  LowStock   :Quantity,
  OutOfStock,
  Discontinued,
}

InventoryItem := %{
  id           :ItemId,
  name         :str,
  description  :str?,
  category     :ItemCategory,
  status       :ItemStatus,
  location     :WarehouseLocation,
  stock_level  :StockLevel,
  price        :Price,
  last_updated :time.Timestamp,
}

-- Validation functions

validate_quantity :(Quantity) bool = |qty|> {
  qty >= 0
}

validate_price :(Price) bool = |price|> {
  price >= 0.0
}

is_low_stock :(StockLevel) bool = |level|> {
  level =>
    LowStock = n ?? n < 10 => true
    InStock = n ?? n < 20  => true
    _                       => false
}

-- Item creation and manipulation

create_item :(id :ItemId, name :str, category :ItemCategory, location :WarehouseLocation, initial_qty :Quantity) InventoryItem! {
  validate_quantity(initial_qty) =>
    false => !!{ "Invalid quantity" }
    true => !{
      InventoryItem%{
        id = id,
        name = name,
        description = ?{ },
        category = category,
        status = ItemStatus&{ available },
        location = location,
        stock_level = initial_qty =>
          0 => StockLevel|{ OutOfStock }
          n ?? n < 20 => StockLevel|{ LowStock = n }
          n => StockLevel|{ InStock = n },
        price = 0.0,
        last_updated = time.now(),
      }
    }
}

update_stock :(item :InventoryItem, delta :Quantity) InventoryItem! {
  new_qty := item.stock_level =>
    InStock = n => n + delta
    LowStock = n => n + delta
    OutOfStock => delta
    Discontinued => !!{ "Cannot update discontinued item" }!

  validate_quantity(new_qty) =>
    false => !!{ "Stock would become negative" }
    true => !{
      InventoryItem%{
        id = item.id,
        name = item.name,
        description = item.description,
        category = item.category,
        status = item.status,
        location = item.location,
        stock_level = new_qty =>
          0 => StockLevel|{ OutOfStock }
          n ?? n < 20 => StockLevel|{ LowStock = n }
          n => StockLevel|{ InStock = n },
        price = item.price,
        last_updated = time.now(),
      }
    }
}

update_price :(item :InventoryItem, new_price :Price) InventoryItem! {
  validate_price(new_price) =>
    false => !!{ "Invalid price" }
    true => !{
      InventoryItem%{
        id = item.id,
        name = item.name,
        description = item.description,
        category = item.category,
        status = item.status,
        location = item.location,
        stock_level = item.stock_level,
        price = new_price,
        last_updated = time.now(),
      }
    }
}

mark_damaged :(item :InventoryItem) InventoryItem {
  InventoryItem%{
    id = item.id,
    name = item.name,
    description = item.description,
    category = item.category,
    status = ItemStatus&{ damaged },
    location = item.location,
    stock_level = StockLevel|{ OutOfStock },
    price = item.price,
    last_updated = time.now(),
  }
}

-- Query functions

find_low_stock :(items :seq[InventoryItem]) seq[InventoryItem] {
  seqops.filter(items, |item|> is_low_stock(item.stock_level))
}

find_by_category :(items :seq[InventoryItem], cat :ItemCategory) seq[InventoryItem] {
  seqops.filter(items, |item|> {
    item.category =>
      Electronics = _ => cat =>
        Electronics = _ => true
        _ => false
      Clothing = _ => cat =>
        Clothing = _ => true
        _ => false
      Food = _ => cat =>
        Food = _ => true
        _ => false
      Furniture => cat =>
        Furniture => true
        _ => false
      Other => cat =>
        Other => true
        _ => false
  })
}

calculate_total_value :(items :seq[InventoryItem]) Price {
  seqops.fold(items, 0.0, |acc, item|> {
    qty := item.stock_level =>
      InStock = n => n
      LowStock = n => n
      _ => 0
    acc + (item.price * (qty :> f64))
  })
}

-- Service definition

InventoryService := @{
  items      :seq[InventoryItem],
  next_id    :ItemId,
  audit_log  :seq[str],
}

InventoryService {
  (initial_items :seq[InventoryItem]) @! {
    log.info("Initializing inventory service")
    @{
      items = initial_items,
      next_id = seqops.length(initial_items) :> ItemId,
      audit_log = seq[str]{ "Service initialized" },
    }
  }

  ~(svc :@) unit {
    log.info("Shutting down inventory service")
    log.flush(svc.audit_log)
  }
}

InventoryProtocol := .{
  add_item    :(name :str, category :ItemCategory, location :WarehouseLocation, qty :Quantity) InventoryItem!,
  get_item    :(id :ItemId) InventoryItem!,
  update_item :(id :ItemId, delta :Quantity) InventoryItem!,
  set_price   :(id :ItemId, price :Price) InventoryItem!,
  list_items  :() seq[InventoryItem],
  low_stock   :() seq[InventoryItem],
}

InventoryService<InventoryProtocol>(svc :@) {
  add_item :(name :str, category :ItemCategory, location :WarehouseLocation, qty :Quantity) InventoryItem! {
    new_item := create_item(svc.next_id, name, category, location, qty)?
    svc.items = seqops.append(svc.items, new_item)
    svc.next_id = svc.next_id + 1
    svc.audit_log = seqops.append(svc.audit_log, "Added item: " + name)
    !{ new_item }
  }

  get_item :(id :ItemId) InventoryItem! {
    result := seqops.find(svc.items, |item|> item.id == id)
    result =>
      ?{ item } => !{ item }
      ?{ } => !!{ "Item not found" }
  }

  update_item :(id :ItemId, delta :Quantity) InventoryItem! {
    item := get_item(id)?
    updated := update_stock(item, delta)?

    idx := find_index(svc.items, id)
    svc.items = seqops.update_at(svc.items, idx, updated)
    svc.audit_log = seqops.append(svc.audit_log, "Updated stock for item: " + item.name)

    !{ updated }
  }

  set_price :(id :ItemId, price :Price) InventoryItem! {
    item := get_item(id)?
    updated := update_price(item, price)?

    idx := find_index(svc.items, id)
    svc.items = seqops.update_at(svc.items, idx, updated)
    svc.audit_log = seqops.append(svc.audit_log, "Updated price for item: " + item.name)

    !{ updated }
  }

  list_items :() seq[InventoryItem] {
    svc.items
  }

  low_stock :() seq[InventoryItem] {
    find_low_stock(svc.items)
  }
}

-- Helper functions

find_index :(items :seq[InventoryItem], id :ItemId) u32 {
  seqops.find_index(items, |item|> item.id == id)
}

-- Example usage
create_inventory :() InventoryService@ {
  warehouse_a := WarehouseLocation%{
    warehouse_id = 1,
    aisle = "A",
    shelf = 1,
    bin = 1,
  }

  initial_items := seq[InventoryItem]{
    create_item(0, "Laptop", ItemCategory|{ Electronics = "Computer" }, warehouse_a, 50)!,
    create_item(1, "T-Shirt", ItemCategory|{ Clothing = "Apparel" }, warehouse_a, 100)!,
    create_item(2, "Apple", ItemCategory|{ Food = time.today() }, warehouse_a, 15)!,
  }

  InventoryService@{ items = initial_items }
}
