- [X] **PRIORITY PHASE - PRESERVE ALL SIGNIFICANT TOKENS IN ORDER IN GREEN NODES**
    - [x] Current state and gaps
        - [x] Already preserved as trailing commas on list elements:
            - [x] Generic args/params: `GenericArgument`, `GenericParameter` include `TrailingComma?`.
            - [x] Union/struct/named tuple lists: `UnionVariantDeclaration`, `FieldDeclaration`, `NamedTupleElement` include `TrailingComma?`.
            - [x] Protocol methods: `MethodSignature` includes `TrailingComma?`.
            - [x] `ModulePath` preserves separators as explicit tokens in `Parts`.
            - [x] Terminators are explicit `GreenToken` members in the module body.
        - [X] Gaps to fix to meet the rule uniformly:
            - [X] FunctionType parameter list: currently stores `StructuralArray<GreenNode>` (commas dropped). Needs element nodes with optional `TrailingComma`.
            - [X] ServiceShape protocol refs list: currently drops commas. Needs element nodes with optional `TrailingComma`.
    - [X] Service impl:
        - [X] StateBlock field list: currently drops commas. `ServiceStateField` should carry optional `TrailingComma`.

- [ ] **PRIORITY PHASE – Module-level typed value bindings**
    - [x] Surface: support `Ident ':' Type '=' Initializer Terminator` and `'@' Ident ':' Type '=' Initializer Terminator` at module scope (init required).
    - [x] Parser: add a Module member prediction for `Identifier ':'` (const) and `'@' Identifier ':'` (mutable); parse header and capture initializer through the next Terminator (structure-only for now).
    - [x] AST: add `ValueDeclaration` node with optional `@` mutability, header tokens, `=` and `Terminator`.
    - [ ] Tests:
        - [ ] Parse: `pi :f32 = 3.14`, `^limit :i32 = 10`.
        - [ ] Error: `x :i32` (no initializer), `<< varName` (policy-dependent), malformed operators.
    - [ ] Docs: expand Fundamentals/Grammar/Expressions once expression parsing lands.
- [ ] **Phase 4 (Option/Result Type Postfix)**
    - [ ] Add type parser support for postfix `?` / `!` creating `OptionTypeNode` / `ResultTypeNode`.
    - [ ] Decide and document chaining precedence (likely restrict ambiguous multi-postfix chains).
    - [ ] Add diagnostics for misuse (postfix applied outside type contexts).
- [ ] **Phase 5 (Services & Protocols)**
    - [ ] Parse protocols: `Proto[...]? : .{ methodSig (, methodSig)* }`.
    - [ ] Parse services: `Service[...]? : ^recv{ state... } (: Proto ('+' Proto)*)? = { members }`.
    - [ ] Members: constructors `^(forms)`, methods (reuse `FunctionDeclaration` after expression layer), destructor `~()`.
- [ ] **Phase 6 – Expression Layer & Operators**
    - [ ] Confirm operator catalogue, precedence tiers, and document a single authoritative table to avoid drift.
    - [ ] Minimal expression parser: identifiers, literals, aggregate constructions `Type%{}`, `Type|{ Variant }`, flags `Type&{}`, tuple `Type#{}`, option/result constructors.
    - [ ] Ensure postfix propagation operators bind tighter than application.
    - [ ] Capture expression grammar invariants and inventory operator/token coverage for LL(k≤4).
    - [x] Adopt `->` lambda sigil across lexer/parser/docs and retire speculative `(params) =>` handling.
    - [ ] Build expression green node hierarchy and extend `SyntaxKind`/`Parser.MapRawKind` accordingly.
    - [ ] Implement primary/call/propagation parsing helpers in a dedicated `Parser.Expressions.cs` partial.
    - [ ] Introduce prefix and binary operator parsing via precedence climbing while respecting streaming constraints.
    - [ ] Rework function literal parsing to emit structured nodes; block expressions now produce statement/value structure.
    - [x] Parse match expressions (`scrutinee => arms`) with guards and expression targets.
    - [ ] Extend diagnostics and recovery paths for expression parsing failures (unexpected postfix, missing operands, stall guard).
    - [ ] Add parser tests plus docs/sample updates confirming expression coverage and error handling.
- [ ] **Phase 8 (Match, Patterns, Loops)**
    - [ ] Pattern AST: Wildcard, Identifier, TuplePattern, VariantPattern, Option/Result Patterns, FlagPattern.
    - [ ] Parse match arms: pattern (guard?) => expr.
    - [ ] CUT: Loop parsing: `@{ ... @}` with `@>` (continue) and `<@ expr` (break).
    - [ ] List rest patterns: Nail down `..rest` rules and exhaustiveness interactions; add 2–3 canonical examples. -- TODO
- [ ] **Semantic Backlog (post-parse)**
    - [ ] Module bindings: reject exports of mutable symbols (or document semantics).
    - [ ] Module bindings: consistent error for stray `:` without a following `=` at module scope.
    - [ ] Services & protocols: diagnostics for missing receiver, duplicate protocols, invalid implements lists.
    - [ ] Expressions: diagnostics for common operator misuse (e.g., mixing incompatible types).
- [ ] **At any time**
    - [ ] Improve comment attachment in `SignficantProducer`.
