- [ ] **PRIORITY PHASE - PRESERVE ALL SIGNIFICANT TOKENS IN ORDER IN GREEN NODES**
    - [x] Current state and gaps
        - [x] Already preserved as trailing commas on list elements:
            - [x] Generic args/params: `GenericArgument`, `GenericParameter` include `TrailingComma?`.
            - [x] Union/struct/named tuple lists: `UnionVariantDeclaration`, `FieldDeclaration`, `NamedTupleElement` include `TrailingComma?`.
            - [x] Protocol methods: `MethodSignature` includes `TrailingComma?`.
            - [x] `ModulePath` preserves separators as explicit tokens in `Parts`.
            - [x] Terminators are explicit `GreenToken` members in the module body.
        - [ ] Gaps to fix to meet the rule uniformly:
            - [ ] FunctionType parameter list: currently stores `StructuralArray<GreenNode>` (commas dropped). Needs element nodes with optional `TrailingComma`.
            - [ ] ServiceShape protocol refs list: currently drops commas. Needs element nodes with optional `TrailingComma`.
    - [ ] Service impl:
        - [ ] StateBlock field list: currently drops commas. `ServiceStateField` should carry optional `TrailingComma`.

- [ ] **PRIORITY PHASE – Module-level typed value bindings**
    - [ ] Surface: support `Ident ':' Type ('=' | '.=') Initializer Terminator` at module scope.
    - [ ] Parser: add a Module member prediction for `Identifier ':'` followed by `=` or `.=`; parse header and capture initializer through the next Terminator.
        - [ ] Phase 0 initializer: accept literals and aggregate constructors; otherwise token-skip to Terminator (structure-only, no expression layer yet).
        - [ ] Phase 1: wire initializer to expression parser once available.
    - [ ] AST: introduce a `ValueDeclaration` green node carrying `Name`, `Colon`, `Type`, `BindOp` (`=` or `.=`), `InitializerTokens`, and `Terminator`.
    - [ ] Diagnostics:
        - [ ] Missing initializer after `=`/`.=`.
        - [ ] Reject exports of var-bound symbols; only const-bound (`=`) may be exported.
        - [ ] Consistent error for stray `:` without a following `=`/`.=` at module scope.
    - [ ] Tests:
        - [ ] Parse: `pi :f32 = 3.14`, `limit :i32 .= 10`.
        - [ ] Error: `x :i32` (no initializer), `<< varName` (exporting var), malformed operators.
    - [ ] Docs: update Core Grammar (Module members), Fundamentals examples, and Expressions linkage once expression parsing lands.
- [ ] **Phase 4 (Option/Result Type Postfix)**
    - [ ] Add type parser support for postfix `?` / `!` creating `OptionTypeNode` / `ResultTypeNode`.
    - [ ] Decide and document chaining precedence (likely restrict ambiguous multi-postfix chains).
    - [ ] Add diagnostics for misuse (postfix applied outside type contexts).
- [ ] **Phase 5 (Services & Protocols)**
    - [ ] Parse protocols: `Proto[...]? : .{ methodSig (, methodSig)* }`.
    - [ ] Parse services: `Service[...]? : ^recv{ state... } (: Proto ('+' Proto)*)? = { members }`.
    - [ ] Members: constructors `^(forms)`, methods (reuse `FunctionDeclaration` after expression layer), destructor `~()`.
    - [ ] Diagnostics: missing receiver, duplicate protocols, invalid implements lists.
- [ ] **Phase 6 (Define basic operators and precedence)**
    - [ ] Define a minimal set of operators (e.g., arithmetic, logical, comparison) with clear precedence and associativity rules.
    - [ ] Implement parsing rules to respect operator precedence and associativity.
    - [ ] Add diagnostics for common operator misuse (e.g., mixing incompatible types).
    - [ ] Precedence table: As operators evolve, add a single authoritative precedence/associativity table (even if sparse now) to avoid drift between files. -- TODO
- [ ] **Phase 7 (Expression Layer Foundations)**
    - [ ] Minimal expression parser: identifiers, literals, aggregate constructions `Type%{}`, `Type|{ Variant }`, flags `Type&{}`, tuple `Type#{}`, option/result constructors.
    - [ ] Postfix propagation operators bind tighter than application.
- [ ] **Phase 8 (Match, Patterns, Loops)**
    - [ ] Pattern AST: Wildcard, Identifier, TuplePattern, VariantPattern, Option/Result Patterns, FlagPattern.
    - [ ] Parse match arms: pattern (guard?) => expr.
    - [ ] Loop parsing: `@{ ... @}` with `@>` (continue) and `<@ expr` (break).
    - [ ] List rest patterns: Nail down `..rest` rules and exhaustiveness interactions; add 2–3 canonical examples. -- TODO
- [ ] **At any time**
    - [ ] Improve comment attachment in `SignficantProducer`.
