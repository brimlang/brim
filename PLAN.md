- [ ] **PRIORITY PHASE - PRESERVE ALL SIGNIFICANT TOKENS IN ORDER IN GREEN NODES**
    - [x] Current state and gaps
        - [x] Already preserved as trailing commas on list elements:
            - [x] Generic args/params: `GenericArgument`, `GenericParameter` include `TrailingComma?`.
            - [x] Union/struct/named tuple lists: `UnionVariantDeclaration`, `FieldDeclaration`, `NamedTupleElement` include `TrailingComma?`.
            - [x] Protocol methods: `MethodSignature` includes `TrailingComma?`.
            - [x] `ModulePath` preserves separators as explicit tokens in `Parts`.
            - [x] Terminators are explicit `GreenToken` members in the module body.
        - [ ] Gaps to fix to meet the rule uniformly:
            - [ ] FunctionType parameter list: currently stores `StructuralArray<GreenNode>` (commas dropped). Needs element nodes with optional `TrailingComma`.
            - [ ] ServiceShape protocol refs list: currently drops commas. Needs element nodes with optional `TrailingComma`.
            - [ ] Service impl:
                - [ ] StateBlock field list: currently drops commas. `ServiceStateField` should carry optional `TrailingComma`.
- [ ] **Phase 4 (Option/Result Type Postfix)**
    - [ ] Add type parser support for postfix `?` / `!` creating `OptionTypeNode` / `ResultTypeNode`.
    - [ ] Decide and document chaining precedence (likely restrict ambiguous multi-postfix chains).
    - [ ] Add diagnostics for misuse (postfix applied outside type contexts).
- [ ] **Phase 5 (Services & Protocols)**
    - [ ] Parse protocols: `Proto[...]? : .{ methodSig (, methodSig)* }`.
    - [ ] Parse services: `Service[...]? : ^recv{ state... } (: Proto ('+' Proto)*)? = { members }`.
    - [ ] Members: constructors `^(forms)`, methods (reuse `FunctionDeclaration` after expression layer), destructor `~()`.
    - [ ] Diagnostics: missing receiver, duplicate protocols, invalid implements lists.
- [ ] **Phase 6 (Define basic operators and precedence)**
    - [ ] Define a minimal set of operators (e.g., arithmetic, logical, comparison) with clear precedence and associativity rules.
    - [ ] Implement parsing rules to respect operator precedence and associativity.
    - [ ] Add diagnostics for common operator misuse (e.g., mixing incompatible types).
    - [ ] Precedence table: As operators evolve, add a single authoritative precedence/associativity table (even if sparse now) to avoid drift between files. -- TODO
- [ ] **Phase 7 (Expression Layer Foundations)**
    - [ ] Minimal expression parser: identifiers, literals, aggregate constructions `Type%{}`, `Type|{ Variant }`, flags `Type&{}`, tuple `Type#{}`, option/result constructors.
    - [ ] Postfix propagation operators bind tighter than application.
- [ ] **Phase 8 (Match, Patterns, Loops)**
    - [ ] Pattern AST: Wildcard, Identifier, TuplePattern, VariantPattern, Option/Result Patterns, FlagPattern.
    - [ ] Parse match arms: pattern (guard?) => expr.
    - [ ] Loop parsing: `@{ ... @}` with `@>` (continue) and `<@ expr` (break).
    - [ ] List rest patterns: Nail down `..rest` rules and exhaustiveness interactions; add 2â€“3 canonical examples. -- TODO
- [ ] **At any time**
    - [ ] Improve comment attachment in `SignficantProducer`.
