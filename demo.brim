[[acme::auth]]

<< User -- the user struct
<< Reply
<< Perms
<< handle

io ::= std::io

User     := %{ id :str, age :i32 }
Reply[T] := |{ Good :T, Error :str }
-- flag width u8
Perms    := &u8{ read, write, exec }
Pair     := #{User, Perms}

-- syntax-only demo (parses; not a working program)

-- function types and aliases
FuncT := (A, B) C
MaybeStr := str?
ResI32 := i32!

-- protocol with method signatures
Proto := .{ get:(Key) Value, put:(Key, Value) unit, }

-- service type (protocol refs only)
IntService[T] := ^{ Proto, }

-- service implementation (syntax-only; bodies may error)
<IntService[T], i>{
  < @accum :T, @call_count :u64, >

  ^(seed :T) {
    @i.accum = seed
    @i.call_count = 0u64
  }

  add(x :T, y :T) T {
    r = x + y
    @i.accum = i.accum + r
    @i.call_count = i.call_count + 1
    r
  }

  to_str() str { sfmt.itoa(i.accum) }
  ~() { }
}

-- non-generic service type + impl (parses structurally)
SimpleSvc := ^{ Proto, }
<SimpleSvc, i>{
  <>
  ^(){}
  ping() unit {}
  ~(){}
}

-- non-generic service with fields
<StatefulSvc, i>{
  < @a :i32, @b :u64, >
  ^(){ @i.a = 0i32; @i.b = 0u64 }
  swap() unit { let tmp = i.a; @i.a = i.b; @i.b = tmp }
  ~(){}
}
